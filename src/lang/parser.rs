use crate::lang::{
    expr::{Expr, Value},
    result::{ParseError, ParseResult},
    statement::{Statement, TimeoutAction},
    token::{Token, TokenType},
};

/// The `Parser` struct is a core component of the language's frontend, responsible for
/// transforming a linear sequence of tokens into a structured abstract syntax tree (AST).
/// This transformation is crucial as it turns the flat, linear syntax of the source code
/// into a tree structure that accurately represents the syntactic relationships and hierarchy
/// in the code. The parser ensures that the code adheres to the language's grammar and reports
/// errors for any syntactic anomalies.
///
/// The parser handles various language constructs like expressions, control flow statements,
/// and variable declarations, ensuring each is parsed according to the language's rules.
///
/// The `Parser` uses recursive descent parsing, a common method for implementing parsers, which
/// involves writing a set of recursive functions where each function is responsible for parsing
/// a specific grammar rule. This approach is simple, easy to understand, and implement but can
/// be less efficient for complex grammars.
pub(crate) struct Parser {
    /// A vector of `Token` instances representing the tokenized input.
    tokens: Vec<Token>,
    /// An index into the `tokens` vector, indicating the current position of the parser.
    cur_pos: usize,
}

impl Parser {
    /// Constructs a new `Parser` instance with a given list of tokens. This constructor
    /// initializes the parser with the provided tokens and sets the current position to the
    /// start of the token stream. The parser is then ready to begin the parsing process.
    ///
    /// # Arguments
    ///
    /// - `tokens`: `Vec<Token>` - A collection of tokens generated by the lexical analyzer. These
    ///   tokens are the input to the parser.
    ///
    /// # Returns
    ///
    /// A new `Parser` instance, ready to start parsing the provided tokens.
    pub(crate) fn with_tokens(tokens: Vec<Token>) -> Self {
        Self { tokens, cur_pos: 0 }
    }

    /// Determines whether the parser has reached the end of the token stream. This method
    /// is used to check if all tokens have been processed, signaling the end of the parsing
    /// process. It's crucial for preventing out-of-bounds access on the token vector.
    ///
    /// # Returns
    ///
    /// `true` if all tokens have been processed, `false` if there are more tokens to parse.
    pub(crate) fn reached_end(&self) -> bool {
        self.cur_pos >= self.tokens.len()
    }

    /// Retrieves a reference to the current token without advancing the parser. This method
    /// is commonly used in predictive parsing, where the parser needs to make decisions based
    /// on the current token without consuming it. It's a form of lookahead, where the parser
    /// peeks at the next token to guide its parsing strategy.
    ///
    /// # Returns
    ///
    /// An `Option<&Token>` representing the current token. Returns `None` if the end of the
    /// token stream has been reached.
    pub(crate) fn peek(&self) -> Option<&Token> {
        self.tokens.get(self.cur_pos)
    }

    /// Peeks at a token at a specified offset from the current position. This method allows
    /// the parser to look further ahead in the token stream, which can be necessary for
    /// making more complex predictive parsing decisions. For instance, this can be used to
    /// distinguish between different types of expressions based on upcoming tokens.
    ///
    /// # Arguments
    ///
    /// - `offset`: usize - The number of tokens to look ahead from the current position.
    ///
    /// # Returns
    ///
    /// An `Option<&Token>` representing the token at the specified offset. Returns `None` if
    /// the specified position is beyond the end of the token stream.
    pub(crate) fn peek_offset(&self, offset: usize) -> Option<&Token> {
        self.tokens.get(self.cur_pos + offset)
    }

    pub(crate) fn peek_or_last(&self) -> Option<&Token> {
        if self.reached_end() {
            self.tokens.last()
        } else {
            self.peek()
        }
    }

    /// Consumes and returns the current token, advancing the parser to the next token. This
    /// method is the primary means by which the parser progresses through the token stream.
    /// Each call to `consume` effectively reads one token from the input and moves the parser's
    /// focus forward, facilitating the sequential processing of tokens.
    ///
    /// # Returns
    ///
    /// An `Option<&Token>` representing the consumed token. Returns `None` if the parser has
    /// already reached the end of the token stream, preventing any further consumption.
    pub(crate) fn consume(&mut self) -> Option<&Token> {
        if self.reached_end() {
            None
        } else {
            let token = self.tokens.get(self.cur_pos);
            self.cur_pos += 1;
            token
        }
    }

    /// Attempts to match the current token with a specified token type and advances the parser
    /// if successful. This method is used when the parser expects a specific token type at
    /// the current position. If the current token matches the expected type, the parser moves
    /// forward; otherwise, it remains at the current position. This mechanism is crucial for
    /// enforcing the correct syntax, as it ensures that the tokens appear in an expected order.
    ///
    /// # Arguments
    ///
    /// - `typ`: &TokenType - The expected type of the current token.
    ///
    /// # Returns
    ///
    /// `true` if the current token matches the expected type and the parser advances; `false`
    /// if the current token does not match or the end of the stream has been reached.
    pub(crate) fn try_match(&mut self, typ: &TokenType) -> bool {
        if self.reached_end() {
            false
        } else {
            let token = self.tokens.get(self.cur_pos);
            if token.map(|t| &t.typ) == Some(typ) {
                self.cur_pos += 1;
                true
            } else {
                false
            }
        }
    }

    /// Synchronizes the parser after encountering an error. This method is used for error
    /// recovery, allowing the parser to continue parsing even after encountering an error.
    /// It works by advancing tokens until a known synchronization point (like a semicolon or
    /// the start of the next statement) is found. This allows the parser to resume parsing
    /// from a known good state, rather than halting completely upon the first error.
    fn sync(&mut self) {
        while let Some(Token { typ, .. }) = self.peek().cloned() {
            self.consume();

            if matches!(typ, TokenType::SemiColon) {
                break;
            }

            if matches!(
                typ,
                TokenType::Let
                    | TokenType::If
                    | TokenType::While
                    | TokenType::Output
                    | TokenType::Exit
                    | TokenType::Input
                    | TokenType::Sleep
                    | TokenType::InputNum
                    | TokenType::State
            ) {
                break;
            }
        }
    }

    /// Parses the next statement in the token stream. This method is the entry point for
    /// parsing different types of statements, such as if-statements, loop statements, and
    /// variable declarations. The method decides which specific parsing function to call
    /// based on the current token. If an error occurs during parsing, the `sync` method
    /// is called to recover and prepare for parsing the next statement.
    ///
    /// # Returns
    ///
    /// `ParseResult<Statement>` - A result that either contains the successfully parsed
    /// statement or a parsing error. The error includes details about what went wrong,
    /// aiding in diagnosing syntax issues.
    fn next_statement(&mut self) -> ParseResult<Statement> {
        let statement = match self.peek().map(|t| &t.typ) {
            Some(TokenType::If) => self.parse_if(),
            Some(TokenType::Else) => Err(ParseError::UnexpectedToken(
                "else".to_string(),
                self.peek_or_last().unwrap().line_num,
            )),
            Some(TokenType::While) => self.parse_while(),
            Some(TokenType::State) => self.parse_state(),
            Some(TokenType::Let) => self.parse_let(),
            Some(TokenType::Input) => self.parse_input(),
            Some(TokenType::InputNum) => self.parse_input_num(),
            Some(TokenType::Output) => self.parse_output(),
            Some(TokenType::Exit) => self.parse_exit(),
            Some(TokenType::Sleep) => self.parse_sleep(),
            Some(TokenType::LeftBrace) => self.parse_block(),
            _ => self.parse_expr_statement(), // not sure if the circumstances should be accepted (or just an error)
        };

        if statement.is_err() {
            self.sync();
        }
        statement
    }

    fn parse_left_brace(&mut self) -> ParseResult<()> {
        if self.peek().is_none() || self.peek_or_last().unwrap().typ != TokenType::LeftBrace {
            Err(ParseError::LeftBraceExpected(
                self.peek_or_last().unwrap().line_num,
            ))
        } else {
            Ok(())
        }
    }

    /// A convenience method for parsing an identifier token. This method is used when parsing
    /// statements that require an identifier, such as variable declarations and function calls.
    /// It ensures that the current token is an identifier and returns it if so. If the current
    /// token is not an identifier, an error is returned.
    ///
    /// # Returns
    ///
    /// `ParseResult<Option<Token>>` - A result that either contains the identifier token or
    /// a parsing error. The error includes details about what went wrong, aiding in diagnosing
    /// syntax issues.
    fn parse_ident(&mut self) -> ParseResult<Option<Token>> {
        // ident is a terminator
        let ident = self.consume().cloned();
        if ident.is_none() || ident.as_ref().unwrap().typ != TokenType::Identifier {
            return Err(ParseError::IdentifierExpected(
                self.peek_or_last().unwrap().line_num,
            ));
        }
        Ok(ident)
    }

    /// Parses an `if` statement, including its condition, then branch, and optional else branch.
    /// The method expects to start at the `if` keyword and consumes tokens until the end of the
    /// `if` statement, handling parentheses around the condition and braces around the branches.
    ///
    /// # Returns
    ///
    /// `ParseResult<Statement>` - The parsed `if` statement or an error if parsing fails.
    fn parse_if(&mut self) -> ParseResult<Statement> {
        // <branch-statement> ::= "branch" "(" <expression> ")" <statement> ("else" <statement>)?
        // do not forget to consume the "if" token
        self.consume();

        // consume the "(" token
        if !self.try_match(&TokenType::LeftParen) {
            return Err(ParseError::LeftParenExpected(
                self.peek_or_last().unwrap().line_num,
            ));
        }

        // parse the condition expression
        let condition = self.parse_expr()?;

        // consume the ")" token
        if !self.try_match(&TokenType::RightParen) {
            return Err(ParseError::RightParenExpected(
                self.peek_or_last().unwrap().line_num,
            ));
        }

        // parse the then branch statement
        let then_branch = Box::new(self.next_statement()?);

        let else_branch = if self.try_match(&TokenType::Else) {
            // consume the "else" token
            Some(Box::new(self.next_statement()?))
        } else {
            // the else branch do not exist
            None
        };

        Ok(Statement::If {
            condition,
            then_branch,
            else_branch,
        })
    }

    /// Parses a `loop` statement, which represents an infinite loop. The method starts at the
    /// `loop` keyword and expects a block of statements as the loop body.
    ///
    /// # Returns
    ///
    /// `ParseResult<Statement>` - The parsed `loop` statement or an error if parsing fails.
    fn parse_while(&mut self) -> ParseResult<Statement> {
        // <while-statement> ::= "while" "(" <expression> ")" <statement>
        // do not forget to consume the "while" token
        self.consume();

        // consume the "(" token
        if !self.try_match(&TokenType::LeftParen) {
            return Err(ParseError::LeftParenExpected(
                self.peek_or_last().unwrap().line_num,
            ));
        }

        // parse the condition expression
        let condition = self.parse_expr()?;

        // consume the ")" token
        if !self.try_match(&TokenType::RightParen) {
            return Err(ParseError::RightParenExpected(
                self.peek_or_last().unwrap().line_num,
            ));
        }

        // parse the loop body
        let body = Box::new(self.next_statement()?);

        Ok(Statement::While { condition, body })
    }

    /// Parses a `state` declaration, used for defining a new state with an optional set of
    /// parameters and a body. The method handles the parsing of the state identifier, parameter
    /// list, and the body.
    ///
    /// # Returns
    ///
    /// `ParseResult<Statement>` - The parsed `state` declaration or an error if parsing fails.
    fn parse_state(&mut self) -> ParseResult<Statement> {
        // <state-declaration> ::= "state" <identifier> "=" <block>
        // do not forget to consume the "state" token
        self.consume();

        // parse the state name identifier
        let ident = self.parse_ident()?;

        // parse the "(" token
        if !self.try_match(&TokenType::LeftParen) {
            return Err(ParseError::LeftParenExpected(
                self.peek_or_last().unwrap().line_num,
            ));
        }

        // parse the parameter list, read until the ")" token
        let mut params = Vec::default();
        while !self.try_match(&TokenType::RightParen) {
            if self.reached_end() {
                return Err(ParseError::RightParenExpected(
                    self.peek_or_last().unwrap().line_num,
                ));
            }

            // parse the parameter identifier
            let param = self.consume();
            if param.is_none() || param.unwrap().typ != TokenType::Identifier {
                return Err(ParseError::IdentifierExpected(
                    self.peek_or_last().unwrap().line_num,
                ));
            }
            params.push(param.unwrap().clone());
        }

        // parse the "{" token
        self.parse_left_brace()?;

        // parse the state body
        let body = match self.parse_block()? {
            Statement::Block(statements) => statements,
            _ => unreachable!(),
        };

        Ok(Statement::State {
            ident: ident.unwrap().clone(),
            params,
            body,
        })
    }

    /// Parses a `let` statement for variable declarations. This method handles the parsing of
    /// variable identifiers, optional initializers, and ensures that the statement ends with a
    /// semicolon.
    ///
    /// # Returns
    ///
    /// `ParseResult<Statement>` - The parsed `let` statement or an error if parsing fails.
    fn parse_let(&mut self) -> ParseResult<Statement> {
        // <variable-declaration> ::= "let" <identifier> "=" <expression> ";"
        // do not forget to consume the "let" token
        self.consume();

        // parse the variable identifier
        let ident = self.parse_ident()?;

        // parse the "=" token. i implemented as <variable-declaration> ::= "let" <identifier> ("=" <expression>)? ";"
        let initialiser = if self.try_match(&TokenType::Assign) {
            Some(self.parse_expr()?)
        } else {
            None
        };

        // parse the ";" token
        if !self.try_match(&TokenType::SemiColon) {
            return Err(ParseError::SemiColonExpected(
                self.peek_or_last().unwrap().line_num,
            ));
        }

        Ok(Statement::Let {
            ident: ident.unwrap().clone(),
            initialiser,
        })
    }

    /// Parses an `input` statement, which reads a line of input into a variable. This method
    /// handles the parsing of the variable identifier and ensures that the statement ends with a
    /// semicolon.
    ///
    /// # Returns
    ///
    /// `ParseResult<Statement>` - The parsed `input` statement or an error if parsing fails.
    fn parse_input(&mut self) -> ParseResult<Statement> {
        // <input-statement> ::= "input" <identifier> ("timeout(" <expression> ")" <statement>)? ";"
        // do not forget to consume the "input" token
        self.consume();

        // parse the variable identifier
        let ident = self.parse_ident()?;

        // parse the timeout action
        let timeout_action = if self.try_match(&TokenType::Timeout) {
            // parse the "(" token
            if !self.try_match(&TokenType::LeftParen) {
                return Err(ParseError::LeftParenExpected(
                    self.peek_or_last().unwrap().line_num,
                ));
            }

            // parse the duration expression
            let duration = self.parse_expr()?;

            // parse the ")" token
            if !self.try_match(&TokenType::RightParen) {
                return Err(ParseError::RightParenExpected(
                    self.peek_or_last().unwrap().line_num,
                ));
            }

            // parse the "{" token
            self.parse_left_brace()?;

            // parse the timeout action
            let action = self.parse_block()?;

            Some(TimeoutAction {
                duration,
                action: Box::new(action),
            })
        } else {
            // no timeout action
            None
        };

        // parse the ";" token
        if !self.try_match(&TokenType::SemiColon) {
            return Err(ParseError::SemiColonExpected(
                self.peek_or_last().unwrap().line_num,
            ));
        }

        Ok(Statement::Input {
            ident: ident.unwrap().clone(),
            timeout_action,
        })
    }

    /// Parses an `input_num` statement, similar to `input` but for numeric input. This method
    /// handles the parsing of the variable identifier and ensures that the statement ends with a
    /// semicolon.
    ///
    /// # Returns
    ///
    /// `ParseResult<Statement>` - The parsed `input_num` statement or an error if parsing fails.
    fn parse_input_num(&mut self) -> ParseResult<Statement> {
        // exactly the same as parse_input!
        let input = self.parse_input()?;
        match input {
            Statement::Input {
                ident,
                timeout_action,
            } => Ok(Statement::InputNum {
                ident,
                timeout_action,
            }),
            _ => unreachable!(),
        }
    }

    /// Parses an `output` statement, which prints an expression's value. This method handles the
    /// parsing of the expression to output and ensures that the statement ends with a semicolon.
    ///
    /// # Returns
    ///
    /// `ParseResult<Statement>` - The parsed `output` statement or an error if parsing fails.
    fn parse_output(&mut self) -> ParseResult<Statement> {
        // <output-statement> ::= "output" <expression> ";"
        // do not forget to consume the "output" token
        self.consume();

        // parse the expression to output
        let expr = self.parse_expr()?;

        // parse the ";" token
        if !self.try_match(&TokenType::SemiColon) {
            return Err(ParseError::SemiColonExpected(
                self.peek_or_last().unwrap().line_num,
            ));
        }

        Ok(Statement::Output(expr))
    }

    /// Parses an `exit` statement, which signals the end of execution. This method ensures that
    /// the `exit` statement is properly formed and ends with a semicolon.
    ///
    /// # Returns
    ///
    /// `ParseResult<Statement>` - The parsed `exit` statement or an error if parsing fails.
    fn parse_exit(&mut self) -> ParseResult<Statement> {
        // <exit-statement> ::= "exit ;"
        // do not forget to consume the "exit" token
        self.consume();

        // parse the ";" token
        if !self.try_match(&TokenType::SemiColon) {
            return Err(ParseError::SemiColonExpected(
                self.peek_or_last().unwrap().line_num,
            ));
        }

        Ok(Statement::Exit)
    }

    /// Parses a `sleep` statement, which delays execution for a specified duration. This method
    /// handles the parsing of the duration expression and ensures that the statement ends with a
    /// semicolon.
    ///
    /// # Returns
    ///
    /// `ParseResult<Statement>` - The parsed `sleep` statement or an error if parsing fails.
    fn parse_sleep(&mut self) -> ParseResult<Statement> {
        // <sleep-statement> ::= "sleep" <expression> ";"
        // do not forget to consume the "sleep" token
        self.consume();

        // parse the duration expression
        let expr = self.parse_expr()?;

        // parse the ";" token
        if !self.try_match(&TokenType::SemiColon) {
            return Err(ParseError::SemiColonExpected(
                self.peek_or_last().unwrap().line_num,
            ));
        }

        Ok(Statement::Sleep(expr))
    }

    /// Parses a block of statements, enclosed in braces. This method is used for parsing the body
    /// of loops, conditionals, and state declarations. It handles multiple statements until the
    /// closing brace is reached.
    ///
    /// # Returns
    ///
    /// `ParseResult<Statement>` - The parsed block of statements or an error if parsing fails.
    fn parse_block(&mut self) -> ParseResult<Statement> {
        // <block-statement> ::= "{" <statement>* "}"
        self.consume();

        // parse the statements until the "}" token
        let mut statements = Vec::default();
        while !self.try_match(&TokenType::RightBrace) {
            if self.reached_end() {
                return Err(ParseError::RightBraceExpected(
                    self.peek_or_last().unwrap().line_num,
                ));
            }

            statements.push(self.next_statement()?);
        }

        Ok(Statement::Block(statements))
    }

    /// Parses an expression statement, which is a standalone expression followed by a semicolon.
    /// This method is used for expressions that are executed for their side effects rather than
    /// their values.
    ///
    /// # Returns
    ///
    /// `ParseResult<Statement>` - The parsed expression statement or an error if parsing fails.
    fn parse_expr_statement(&mut self) -> ParseResult<Statement> {
        // <expression-statement> ::= <expression> ";"
        // parse the <expression>
        let expr = self.parse_expr()?;
        // parse the ";" token
        if !self.try_match(&TokenType::SemiColon) {
            return Err(ParseError::SemiColonExpected(
                self.peek_or_last().unwrap().line_num,
            ));
        }
        Ok(Statement::Expression(expr))
    }

    /// Parses a general expression, starting from the lowest precedence level. This method is the
    /// entry point for parsing any expression and will delegate to more specific expression parsing
    /// methods based on the current token. It handles binary operations, assignment, and other
    /// expressions by recognizing their specific patterns and syntax rules.
    ///
    /// # Returns
    ///
    /// `ParseResult<Expr>` - The parsed expression or an error if parsing fails.
    fn parse_expr(&mut self) -> ParseResult<Expr> {
        // <expression> ::= <identifier> "=" <expression>
        //                | <comparison>

        if let Some(token) = self.peek().cloned() {
            if token.typ == TokenType::Identifier
                && self.peek_offset(1).map(|t| &t.typ) == Some(&TokenType::Assign)
            {
                self.consume();
                self.consume();
                let rhs = self.parse_expr()?;
                return Ok(Expr::Assign {
                    lhs: token,
                    rhs: Box::new(rhs),
                });
            }
        }

        self.parse_comp()
    }

    /// Parses a comparison expression, dealing with comparison operators like '==' and '!='.
    /// It is part of the expression parsing hierarchy and is called when comparison operators
    /// are encountered. This method will recursively call itself or other expression parsing
    /// methods to handle the operands of the comparison.
    ///
    /// # Returns
    ///
    /// `ParseResult<Expr>` - The parsed comparison expression or an error if parsing fails.
    fn parse_comp(&mut self) -> ParseResult<Expr> {
        // <comparison> ::= <logic> ("~=" | "==" | "!=" | "<" | "<=" | ">" | ">=") <logic>
        let mut expr = self.parse_logic()?;

        while let Some(op) = self.peek().cloned() {
            match op.typ {
                TokenType::Equal
                | TokenType::NotEqual
                | TokenType::Less
                | TokenType::LessEqual
                | TokenType::Greater
                | TokenType::GreaterEqual
                | TokenType::Match => {
                    self.consume();
                    let rhs = self.parse_logic()?;
                    expr = Expr::Binary {
                        lhs: Box::new(expr),
                        op: op.clone(),
                        rhs: Box::new(rhs),
                    };
                }
                _ => break,
            }
        }

        Ok(expr)
    }

    fn parse_logic(&mut self) -> ParseResult<Expr> {
        // <logic> ::= <arithmetic> (("&&" | "||") <arithmetic>)*
        let mut expr = self.parse_arith()?;

        while let Some(op) = self.peek().cloned() {
            if matches!(op.typ, TokenType::LAnd | TokenType::LOr) {
                self.consume();
                let rhs = self.parse_arith()?;
                expr = Expr::Binary {
                    lhs: Box::new(expr),
                    op: op.clone(),
                    rhs: Box::new(rhs),
                };
            } else {
                break;
            }
        }

        Ok(expr)
    }

    /// Parses an arithmetic expression, handling operators like '+' and '-'. This method fits
    /// into the expression parsing hierarchy and deals with arithmetic operations. It calls
    /// itself or other parsing methods recursively to resolve operands, respecting operator
    /// precedence and associativity.
    ///
    /// # Returns
    ///
    /// `ParseResult<Expr>` - The parsed arithmetic expression or an error if parsing fails.
    fn parse_arith(&mut self) -> ParseResult<Expr> {
        // <arithmetic> ::= <unary> (("+" | "-") <unary>)*
        let mut expr = self.parse_unary()?;

        while let Some(op) = self.peek().cloned() {
            match op.typ {
                TokenType::Plus | TokenType::Minus => {
                    self.consume();
                    let rhs = self.parse_unary()?;
                    expr = Expr::Binary {
                        lhs: Box::new(expr),
                        op: op.clone(),
                        rhs: Box::new(rhs),
                    };
                }
                _ => break,
            }
        }

        Ok(expr)
    }

    /// Parses a unary expression, which includes unary operators like '!', '+', and '-' applied
    /// to a single operand. This method is responsible for recognizing these unary operations and
    /// parsing their operand, which might be any other kind of expression.
    ///
    /// # Returns
    ///
    /// `ParseResult<Expr>` - The parsed unary expression or an error if parsing fails.
    fn parse_unary(&mut self) -> ParseResult<Expr> {
        // <unary> ::= ("+" | "-" | "!") <unary>
        //           | <call>
        if let Some(op) = self.peek().cloned() {
            if matches!(op.typ, TokenType::Plus | TokenType::Minus | TokenType::Bang) {
                self.consume();
                let rhs = self.parse_unary()?;
                return Ok(Expr::Unary {
                    op: op.clone(),
                    rhs: Box::new(rhs),
                });
            }
        }

        self.parse_call()
    }

    /// Parses a function call or a simpler atom. If the current token suggests a function call
    /// (e.g., an identifier followed by a '('), it processes the function call with its
    /// arguments. Otherwise, it delegates to `parse_atom` to handle simpler expressions like
    /// literals or grouped expressions.
    ///
    /// # Returns
    ///
    /// `ParseResult<Expr>` - The parsed call expression or an atom, or an error if parsing fails.
    fn parse_call(&mut self) -> ParseResult<Expr> {
        // <call> ::= <atom> ("(" <arguments> ")")?
        // <arguments> ::= <expression> (" " <expression>)*
        let mut expr = self.parse_atom()?;
        if self.peek().map(|t| &t.typ) == Some(&TokenType::LeftParen) {
            self.consume();
            let mut args = Vec::default();
            while !self.try_match(&TokenType::RightParen) {
                if self.reached_end() {
                    return Err(ParseError::RightParenExpected(
                        self.peek_or_last().unwrap().line_num,
                    ));
                }

                args.push(self.parse_expr()?);
            }
            expr = Expr::Call {
                func: Box::new(expr),
                args,
            };
        }
        Ok(expr)
    }

    /// Parses an atom, which represents the simplest part of an expression, like a literal,
    /// a variable, or a parenthesized expression. This method is the lowest level of the
    /// expression parsing hierarchy, returning the most basic elements that make up expressions.
    ///
    /// # Returns
    ///
    /// `ParseResult<Expr>` - The parsed atom or an error if parsing fails.
    fn parse_atom(&mut self) -> ParseResult<Expr> {
        // <atom> ::= <identifier>
        //          | <number>
        //          | <string>
        //          | <boolean>
        //          | <nil>
        //          | "(" <expression> ")"
        if let Some(token) = self.consume() {
            match &token.typ {
                TokenType::Number(n) => Ok(Expr::Literal(Value::Number(*n))),
                TokenType::Str(s) => Ok(Expr::Literal(Value::Str(s.clone()))),
                TokenType::Identifier => Ok(Expr::Variable(token.clone())),
                TokenType::LeftParen => {
                    let expr = self.parse_expr()?;
                    if !self.try_match(&TokenType::RightParen) {
                        return Err(ParseError::RightParenExpected(
                            self.peek_or_last().unwrap().line_num,
                        ));
                    }
                    Ok(expr)
                }
                TokenType::True => Ok(Expr::Literal(Value::Boolean(true))),
                TokenType::False => Ok(Expr::Literal(Value::Boolean(false))),
                TokenType::Nil => Ok(Expr::Literal(Value::Nil)),
                _ => Err(ParseError::UnexpectedToken(
                    token.lexeme.clone(),
                    token.line_num,
                )),
            }
        } else {
            Err(ParseError::UnexpectedEof)
        }
    }

    /// Parses the entire token list into a series of statements, representing the program's AST.
    /// This method repeatedly calls `next_statement` until the end of the token stream is reached.
    /// Each parsed statement is added to a vector, forming the complete parsed representation
    /// of the input program. Errors encountered during parsing of individual statements are
    /// included in the result, allowing for error reporting and diagnostics.
    ///
    /// # Returns
    ///
    /// `Vec<ParseResult<Statement>>` - A vector containing the parsed statements or any parsing
    /// errors encountered. This comprehensive list represents the entire parsed program.
    pub(crate) fn parse(&mut self) -> Vec<ParseResult<Statement>> {
        let mut statements = Vec::default();
        while !self.reached_end() {
            statements.push(self.next_statement());
        }
        statements
    }

    /// Parse the entire token list into a series of statements, excluding any parsing errors.
    /// This method is a convenience wrapper around `parse`, which returns a tuple containing
    /// the parsed statements and any errors encountered. This method simply extracts the
    /// statements from the tuple, discarding any errors.
    ///
    /// # Returns
    ///
    /// `(Vec<Statement>, Vec<ParseError>)` - A tuple containing the parsed statements and any
    /// parsing errors encountered respectively.
    pub(crate) fn parse_effective(&mut self) -> (Vec<Statement>, Vec<ParseError>) {
        let mut statements = Vec::default();
        let mut errors = Vec::default();

        for statement in self.parse() {
            match statement {
                Ok(statement) => statements.push(statement),
                Err(error) => errors.push(error),
            }
        }

        (statements, errors)
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::lang::lexer::Lexer;

    #[test]
    fn if_() {
        let (tokens, errors) = Lexer::with_source("if (true) { }").lex_effective();
        assert!(errors.is_empty());

        let statement = Parser::with_tokens(tokens).parse_if().unwrap();
        // eprintln!("{:#?}", statement);
        assert_eq!(format!("{}", statement), "if ([Literal true]) { }");
    }

    #[test]
    fn loop_() {
        let (tokens, errors) = Lexer::with_source("while (true) { }").lex_effective();
        assert!(errors.is_empty());

        let statement = Parser::with_tokens(tokens).parse_while().unwrap();
        // eprintln!("{:#?}, statement");
        assert_eq!(format!("{}", statement), "while ([Literal true]) { }");
    }

    #[test]
    fn state() {
        let (tokens, errors) = Lexer::with_source("state foo(a b) { output a; }").lex_effective();
        assert!(errors.is_empty());

        let statement = Parser::with_tokens(tokens).parse_state().unwrap();
        // eprintln!("{:#?}", statement);
        assert_eq!(
            format!("{}", statement),
            "state [Ident: foo]([Ident: a] [Ident: b] ) { output [Expr: [Variable a]]; }"
        );
    }

    #[test]
    fn let_() {
        let (tokens, errors) = Lexer::with_source("let a = 1;").lex_effective();
        assert!(errors.is_empty());

        let statement = Parser::with_tokens(tokens).parse_let().unwrap();
        // eprintln!("{:#?}", statement);
        assert_eq!(format!("{}", statement), "let [Ident: a] = [Literal 1];");
    }

    #[test]
    fn input_output() {
        let (tokens, errors) = Lexer::with_source("input a;").lex_effective();
        assert!(errors.is_empty());

        let statement = Parser::with_tokens(tokens).parse_input().unwrap();
        // eprintln!("{:#?}", statement);
        assert_eq!(format!("{}", statement), "input [Ident: a];");

        let (tokens, errors) = Lexer::with_source("input_num a;").lex_effective();
        assert!(errors.is_empty());

        let statement = Parser::with_tokens(tokens).parse_input_num().unwrap();
        // eprintln!("{:#?}", statement);
        assert_eq!(format!("{}", statement), "input_num [Ident: a];");

        let (tokens, errors) = Lexer::with_source("output 1;").lex_effective();
        assert!(errors.is_empty());

        let statement = Parser::with_tokens(tokens).parse_output().unwrap();
        // eprintln!("{:#?}", statement);
        assert_eq!(format!("{}", statement), "output [Expr: [Literal 1]];");
    }

    #[test]
    fn exit() {
        let (tokens, errors) = Lexer::with_source("exit;").lex_effective();
        assert!(errors.is_empty());

        let statement = Parser::with_tokens(tokens).parse_exit().unwrap();
        // eprintln!("{:#?}", statement);
        assert_eq!(format!("{}", statement), "exit;");
    }

    #[test]
    fn sleep() {
        let (tokens, errors) = Lexer::with_source("sleep 1;").lex_effective();
        assert!(errors.is_empty());

        let statement = Parser::with_tokens(tokens).parse_sleep().unwrap();
        // eprintln!("{:#?}", statement);
        assert_eq!(format!("{}", statement), "sleep [Expr: [Literal 1]];");
    }

    #[test]
    fn block() {
        let (tokens, errors) = Lexer::with_source("{ }").lex_effective();
        assert!(errors.is_empty());

        let statement = Parser::with_tokens(tokens).parse_block().unwrap();
        // eprintln!("{:#?}", statement);
        assert_eq!(format!("{}", statement), "{ }");
    }

    #[test]
    fn expr_statement() {
        let (tokens, errors) = Lexer::with_source("1;").lex_effective();
        assert!(errors.is_empty());

        let statement = Parser::with_tokens(tokens).parse_expr_statement().unwrap();
        // eprintln!("{:#?}", statement);
        assert_eq!(format!("{}", statement), "[Expr: [Literal 1]];");
    }

    #[test]
    fn expr() {
        let src = "baz = qau != foo(bar (114514 == 2 + -3 - 4 + 5 - 6))";
        let (tokens, errors) = Lexer::with_source(src).lex_effective();
        assert!(errors.is_empty());

        let expr = Parser::with_tokens(tokens).parse_expr().unwrap();
        // eprintln!("{:#?}", expr);
        assert_eq!(
            format!("{}", expr),
            "[Assign Identifier baz <- [Binary != [Variable qau] [Call [Variable foo] with [Call [Variable bar] with [Binary == [Literal 114514] [Binary - [Binary + [Binary - [Binary + [Literal 2] [Unary - [Literal 3]]] [Literal 4]] [Literal 5]] [Literal 6]]]]]]]"
        );
    }

    #[test]
    fn expr2() {
        let src = "foo(bar(1 2 (+ 3)) 4 5)";
        let (tokens, errors) = Lexer::with_source(src).lex_effective();
        assert!(errors.is_empty());

        let expr = Parser::with_tokens(tokens).parse_expr().unwrap();
        // eprintln!("{:#?}", expr);
        assert_eq!(
            format!("{}", expr),
            "[Call [Variable foo] with [Call [Variable bar] with [Literal 1] [Call [Literal 2] with [Unary + [Literal 3]]]] [Literal 4] [Literal 5]]"
        );
    }

    #[test]
    #[should_panic]
    fn parse_expr_wrong() {
        let src = "foo(2 +) 3";
        let (tokens, errors) = Lexer::with_source(src).lex_effective();
        assert!(errors.is_empty());

        let expr = Parser::with_tokens(tokens).parse_expr().unwrap();
        // eprintln!("{:#?}", expr);
        assert_eq!(
            format!("{}", expr),
            "[Call [Variable foo] with [Call [Variable bar] with [Literal 1] [Call [Literal 2] with [Unary + [Literal 3]]]] [Literal 4] [Literal 5]]"
        );
    }

    #[test]
    fn complicated() {
        #[rustfmt::skip]
            let src = r#"
状态 测试() {
    input_num x;
    输出 "测试状态 " + (x + 1);
}

while (true) {
    input str;
    branch (str == "in") {
        输出 "in";
    } else {
        输出 "out";
    }
}
"#;
        let (tokens, errors) = Lexer::with_source(src).lex_effective();
        assert!(errors.is_empty());

        let statements = Parser::with_tokens(tokens).parse();
        assert_eq!(statements.len(), 2);
        assert_eq!(
            format!("{}", statements[0].as_ref().unwrap()),
            "state [Ident: 测试]() { input_num [Ident: x]; output [Expr: [Binary + [Literal \"测试状态 \"] [Binary + [Variable x] [Literal 1]]]]; }"
        );
        assert_eq!(
            format!("{}", statements[1].as_ref().unwrap()),
            "while ([Literal true]) { input [Ident: str]; if ([Binary == [Variable str] [Literal \"in\"]]) { output [Expr: [Literal \"in\"]]; } else { output [Expr: [Literal \"out\"]]; } }"
        );
    }

    #[test]
    fn complicated_wrong() {
        #[rustfmt::skip]
            let src = r#"
state test(a b)
    output a + b;
}

test(1 2 3);
test(1 2 3)
output "cannot reach here";
output "syncronised";
"#;
        let (tokens, errors) = Lexer::with_source(src).lex_effective();
        assert!(errors.is_empty());

        let (_, errors) = Parser::with_tokens(tokens).parse_effective();
        assert_eq!(errors.len(), 3);
        assert_eq!(format!("{}", errors[0]), "Left brace expected at line 3.");
        assert_eq!(format!("{}", errors[1]), "Unexpected token '}' at line 4.");
        assert_eq!(format!("{}", errors[2]), "Semicolon expected at line 8.");
    }
}
